#### TESTING RELATED ####

test_stat_20240918<-function(mat_1,mat_2,max_k){
  # This function returns the sum of the top 1,2,...,max_k singular values, plus the sum of squares, 
  # plus the frobenius norm of the matrix of the differenc between mat_1 and mat_2
  # INPUT 
  # mat_1         - pxn matrix
  # mat_2         - pxn matrix
  # k             - integer, maximum singular value to compute
  # OUTPUT
  # test_stat_vec - a named vector with calculated test statistics
  
  diff_mat = mat_1-mat_2
  
  top_k_singular_values = sort(RSpectra::svds(diff_mat,k=max_k,nu=0,nv=0)$d,decreasing=TRUE)
  
  test_stat_values = c(cumsum(top_k_singular_values),
                       cumsum(top_k_singular_values**2),
                       sum(diff_mat**2))
  test_stat_names = c(paste("sum", 1:max_k, sep="_"),
                      paste("sumsq", 1:max_k, sep="_"),
                      'Frobenius')
  
  test_stat_vec = test_stat_values
  names(test_stat_vec) = test_stat_names
  
  return(test_stat_vec)
}

max_k_calculation<-function(combined_mat,max_k_pct,cov_cor='cov'){
  # This function calculates the smallest k, such that the sum of the top k singular values of the covariance/correlation
  # matrix of the data is at least max_k_pct
  # INPUT
  # combined_mat          - pxn matrix of observations
  # max_k_pct             - between 0 and 1, percentage of sum of singular values we wish to cutoff at
  # cov_cor               - whether to use covariance or correlation matrix of data
  
  if(cov_cor == 'cov'){
    combined_singular_values = svd(cov(t(combined_mat)))$d
  }else if(cov_cor == 'cor'){
    combined_singular_values = svd(cor(t(combined_mat)))$d
  }
  
  singular_value_cutoff = max_k_pct * sum(combined_singular_values)
  max_k = which(cumsum(combined_singular_values) >= singular_value_cutoff)[1]
  
  return(max_k)
}

count_greater_than_equal_to <- function(column) {
  # This function takes in a column and counts how many other elements of the column are greater than
  # or equal to each element in the column
  # INPUT
  # column - a vector
  # OUTPUT
  # a vector of same length with counts of how other many elements in column less than each element
  sapply(column, function(x) sum(column >= x)-1)
}

# Test
# mat <- matrix(c(5, 3, 8, 7, 6, 2), nrow=3, byrow=TRUE)
# apply(mat,2,count_greater_than_equal_to)
# 

calc_permutation_stat_matrix <- function(combined_data,n_group_1,n_group_2,max_k,B,observed_test_stats,
                                         cov_cor = 'cov'){
  # This function calculates test statistics for B permutations of the data
  # INPUT
  # combined_data            - p x (n_group_1 + n_group_2) matrix of data
  # n_group_1                - size of group 1
  # n_group_2                - size of group 2
  # max_k                    - maximum k to use when calculating Ky-Fan(k) norms
  # B                        - number of permutations
  # cov_cor                  - whether to use covariance or correlation matrix
  # observed_test_stats      - vector of test statistics using observed data
  # OUTPUT
  # permutation_stat_matrix  - B x L matrix of L test statistics per permutation with named columns
  
  # Create empty matrix of permutation statistics we will fill
  permutation_stat_matrix = matrix(data=0,nrow=B,ncol=length(observed_test_stats))
  colnames(permutation_stat_matrix) = names(observed_test_stats)
  
  # Get the test_stat_prefixes (needed to calculate test statistics with)
  test_stat_prefixes = get_prefixes(names(observed_test_stats))
  
  # Permute data and record test statistics using permuted data in permutation_stat_matrix
  for(j in 1:B){
    permuted_order = sample(1:ncol(combined_data))
    
    permuted_group_1 = combined_data[,permuted_order[1:n_group_1]]
    permuted_group_2 = combined_data[,permuted_order[(n_group_1+1):(n_group_1+n_group_2)]]
    
    if(cov_cor == 'cov'){
      permuted_test_stat = test_stat_20240925(cov(t(permuted_group_1)),
                                              cov(t(permuted_group_2)),
                                              max_k,
                                              test_stat_prefixes)
    }else if(cov_cor == 'cor'){
      permuted_test_stat = test_stat_20240925(cor(t(permuted_group_1)),
                                              cor(t(permuted_group_2)),
                                              max_k,
                                              test_stat_prefixes)
    }
    
    
    permutation_stat_matrix[j,] = c(permuted_test_stat)
  }
  
  return(permutation_stat_matrix)
  
}

calc_permutation_p_value_matrix<-function(permutation_stat_matrix){
  # This function takes a matrix of test statistics for different permutations
  # and returns the p-values for each permutation
  # INPUT
  # permutation_stat_matrix      - B x L matrix of L test statistics per permutation
  # OUTPUT
  # permutation_p_value_matrix   - B X L matrix of L p-values per permutation
  
  permutation_p_value_matrix = (nrow(permutation_stat_matrix)
                                - apply(permutation_stat_matrix,2,rank,ties.method='min')
                                +1)/nrow(permutation_stat_matrix)
  
  return(permutation_p_value_matrix)
}

permutation_add_min_p_cols<-function(permutation_p_value_matrix){
  # This function takes a permutation p value matrix and adds columns that take a minimum p
  # across a series of columns with a shared prefix. Note here the p value that ends up in the min p column
  # is not a true p value (since it is taking minimum across other p values).
  # INPUT
  # p_value_matrix               - C x L matrix of L p-values (C=# of permutations)
  # OUTPUT
  # p_value_matrix               - C x (L + length(col_prefixes)) of p-values and min p-values (i.e. columns)
  #                                with min_p are not 'true' p-values

  for(prefix in get_prefixes(colnames(permutation_p_value_matrix))){
    # Select columns we wish to take a minimum of p values across and take minimum
    prefix_cols = grep(paste(prefix,'_',sep=''),colnames(permutation_p_value_matrix),value=TRUE)
    prefix_min_p = apply(permutation_p_value_matrix[,prefix_cols,drop=FALSE],1,min)
    
    # Add minimum for all permutations to permutation_p_value_matrix
    permutation_p_value_matrix = cbind(permutation_p_value_matrix,prefix_min_p)
    colnames(permutation_p_value_matrix)[ncol(permutation_p_value_matrix)] = paste(prefix,'_min_p',sep='')
  }
  
  # Add min_p across all statistics
  permutation_p_value_matrix = cbind(permutation_p_value_matrix,apply(permutation_p_value_matrix,1,min)) 
  colnames(permutation_p_value_matrix)[ncol(permutation_p_value_matrix)] = 'all_min_p'

  return(permutation_p_value_matrix)
}

observed_add_min_p_cols<-function(observed_p_values,permutation_p_value_matrix){
  # This function takes a observed p value vector, and adds a p-value for the min P (as a true p value)
  # INPUT
  # observed_p_values            - C x L matrix of L p-values (C=# of permutations or 1 for observed test stats)
  # col_prefixes                 - vector of prefixes, we use these prefixes and take a minimum across
  #                                the p-values of permutation_p_value_matrix
  # OUTPUT
  # p_value_matrix               - C x (L + length(col_prefixes)) of p-values, 
  #                                note here all columns are true p-values
  
  # Determine the minimum p value that was observed across all individual statistics
  observed_p_values = matrix(observed_p_values,nrow=1,dimnames = list(NULL, names(observed_p_values)))
  all_min_p_value = min(observed_p_values)
  
  for(prefix in c(get_prefixes(colnames(observed_p_values)),'all')){
    if(prefix != 'all'){
      # For a prefix (e.g. sum, sumsq) find min p value of observed test statistics with this
      # prefix
      prefix_cols = grep(paste(prefix,'_',sep=''),colnames(observed_p_values),value=TRUE)
      prefix_min_p = apply(observed_p_values[,prefix_cols,drop=FALSE],1,min)
    }else{
      prefix_min_p = all_min_p_value
    }  
    # Calculate the p value of this minimum p value (by comparing to minimum p values of permutatinos)
    prefix_min_p_p_value = ((sum(permutation_p_value_matrix[,paste(prefix,'min','p',sep='_')] <= prefix_min_p) + 1) /
                              (nrow(permutation_p_value_matrix) + 1)) 
    observed_p_values = cbind(observed_p_values,prefix_min_p_p_value)
    colnames(observed_p_values)[ncol(observed_p_values)] = paste(prefix,'min','p',sep='_')
  }
  
  return(observed_p_values)
}

calc_observed_p_values<-function(observed_test_stats,permutation_stat_matrix){
  # This function calculates the p-valuse of the observed test statistics using the
  # permuted data
  # INPUT
  # observed_test_stats     - 1 x L vector of test statistics
  # permutation_stat_matrix - B x L matrix of test statistics from different permutatinos of the data
  
  observed_p_values = (colSums(t(t(permutation_stat_matrix)>=observed_test_stats))+1)/(nrow(permutation_stat_matrix)+1)
  
  return(observed_p_values)
}

test_stat_20240925<-function(mat_1,mat_2,max_k,test_stat_prefixes){
  # This function returns the sum of the top 1,2,...,max_k singular values, plus the sum of squares, 
  # plus the frobenius norm of the matrix of the difference between the matrices mat_1 and mat_2
  # INPUT 
  # mat_1                 - pxp matrix
  # mat_2                 - pxp matrix
  # max_k                 - integer, maximum singular value to compute
  # test_stat_prefixes    - strings indicating what statistics to compute (e.g. sum, sumsq, frob)
  # OUTPUT
  # test_stat_vec - a named vector with calculated test statistics
  
  diff_mat = mat_1-mat_2

  top_k_singular_values = sort(RSpectra::svds(diff_mat,k=max_k,nu=0,nv=0)$d,decreasing=TRUE)
  
  test_stat_values = c()
  test_stat_names = c()
  
  if('sum' %in% test_stat_prefixes){
    test_stat_values = c(test_stat_values, cumsum(top_k_singular_values))
    test_stat_names = c(test_stat_names, paste("sum", 1:max_k, sep="_"))
  }
  if('sumsq' %in% test_stat_prefixes){
    test_stat_values = c(test_stat_values,cumsum(top_k_singular_values**2))  
    test_stat_names = c(test_stat_names, paste("sumsq", 1:max_k, sep="_"))
  }
  if('frob' %in% test_stat_prefixes){
    test_stat_values = c(test_stat_values,sum(diff_mat**2))
    test_stat_names = c(test_stat_names, 'frob_all')
  }
  
  names(test_stat_values) = test_stat_names
  
  return(test_stat_values)
}

test_equality_cov_20240925<-function(mat_1,mat_2,max_k,test_stat_prefixes,B,alpha,
                                     cov_cor='cov'){
  # This function takes in two data matrices, and tests for the equality of them using permutation
  # INPUT
  # mat_1              - pxn data matrix
  # mat_2              - pxn data matrix
  # max_k              - integer, maximum singular value to compute
  # test_stat_prefixes - strings indicating what statistics to compute (e.g. sum, sumsq, frob)
  # B                  - number of permutations
  # alpha              - type 1 error rate
  # cov_cor            - whether to test equality of covariance or correlation
  # OUTPUT
  # reject_matrix      - 1xL matrix with named columns, each column  is 0/1 indicating if we reject the null
  #                      hypothesis using a particular test statistic
  
  if(cov_cor == 'cov'){
    cov_cor_mat_1 = cov(t(mat_1))
    cov_cor_mat_2 = cov(t(mat_2))
  }else if(cov_cor == 'cor'){
    cov_cor_mat_1 = cor(t(mat_1))
    cov_cor_mat_2 = cor(t(mat_2))
  }
  
  observed_test_stats = test_stat_20240925(cov_cor_mat_1,cov_cor_mat_2,
                                           max_k,
                                           test_stat_prefixes)
  
  permutation_stat_matrix = calc_permutation_stat_matrix(cbind(mat_1,mat_2),
                                                       ncol(mat_1),
                                                       ncol(mat_2),
                                                       max_k,B,
                                                       observed_test_stats,
                                                       cov_cor=cov_cor)

  permutation_p_value_matrix = calc_permutation_p_value_matrix(permutation_stat_matrix)  
  permutation_p_value_matrix = permutation_add_min_p_cols(permutation_p_value_matrix)
  
  observed_p_values = calc_observed_p_values(observed_test_stats,permutation_stat_matrix)
  observed_p_values = observed_add_min_p_cols(observed_p_values,
                                              permutation_p_value_matrix)
  
  reject_matrix = (observed_p_values <= alpha)*1  
  
  return(reject_matrix)
}

get_prefixes<-function(name_vec){
  # This function gets the unique prefixes from a name vector in format XXX_A, where XXX a string
  # and A a number or 'all'
  # INPUT
  # name_vec        - vector of strings
  # OUTPUT
  # prefixes        - prefixes (what appears before '_' in strings)
  
  return(unique(sapply(strsplit(name_vec, "_"), `[`, 1)))
  
}

#### SIMULATION HELPER ####
setup_directory_and_experiment_df<-function(experiment_df,job_num,RESULTS_DIR,function_name){
  # This function checks if there exists a folder to put the results, creates it if there is not,
  # writes the experiment_df to this folder, and based on what the job is runs the appropriate
  # rows of the experiment_df
  # INPUT
  # experiment_df       - df with all experiments (i.e. combinations of hyperparameters)
  # job_num             - job number (999 is run all, != 999 is specific job to run)
  # RESULTS_DIR         - folder where results for different simulations being written
  # OUTPUT
  # experiment_df       - experiment_df if job_num = 999, for job_num!= 999 returns a row
  #                       of the experiment_df
  
  # Setups Results Directory
  setwd(RESULTS_DIR)
  if(!file.exists(function_name)){
    dir.create(file.path(RESULTS_DIR,function_name))
  }
  
  setwd(file.path(RESULTS_DIR,function_name))
  write.csv(experiment_df,file='experiment_df.csv') 
  
  # Determine which row of experiment_df to run
  if(job_num==999){
    # run all experiments
  }else{
    experiment_df=experiment_df[job_num,]
  }
  
  return(experiment_df)
}

save_experiment_result_to_RDS<-function(experiment_number,function_name,RESULTS_DIR,experiment_results){
  # This function takes the output of a foreach loop and saves it to a RDS file
  # INPUT
  # experiment_number        - integer number of experiment
  # function_name            - name of simulation being run
  # RESULTS_DIR              - folder where all results stored
  # experiment_results       - output of the foreach loop
  
  # Print out message to show experiment done and write results to csv
  print(paste(experiment_number,Sys.time()))
  setwd(file.path(RESULTS_DIR,function_name))
  filename=paste(function_name,'-',sprintf("%03d",experiment_number),'.RDS',sep='')
  saveRDS(experiment_results,file=filename)
}

