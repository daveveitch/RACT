X_1=matrix(rnorm(500),nrow=50)
dim(X_1)
X_1=matrix(rnorm(500),nrow=25)
X_1
stop("test")
mat_1=matrix(rnorm(10000),nrow=100)
mat_2=matrix(rnorm(10000),nrow=100)
diff_mat = cov_cor_X_1-cov_cor_X_2
cov_cor_X_1=matrix(rnorm(10000),nrow=100)
cov_cor_X_2=matrix(rnorm(10000),nrow=100)
diff_mat = cov_cor_X_1-cov_cor_X_2
top_k_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
K=c(1,2,3,5)
top_k_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
top_k_singular_values
top_K_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
top_k_singular_values
diff_mat = cov_cor_X_1-cov_cor_X_2
top_K_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
ky_fan_k_norms = c()
for(k in K){
ky_fan_k_norms = c(ky_fan_k_norms, cumsum(ky_fan_k_norms[1:k]))
}
ky_fan_k_norms
diff_mat = cov_cor_X_1-cov_cor_X_2
top_K_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
ky_fan_k_norms = c()
for(k in K){
ky_fan_k_norms = c(ky_fan_k_norms, cumsum(top_K_singular_values[1:k]))
}
ky_fan_k_norms
K
K
ky_fan_k_norms = cumsum(top_K_singular_values)[K]
ky_fan_k_norms
top_K_singular_values
names(ky_fan_k_norms) = K
ky_fan_k_norms
diff_mat = cov_cor_X_1-cov_cor_X_2
# Calculate top K singular values of difference matrix
top_K_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
ky_fan_k_norms = cumsum(top_K_singular_values)[K]
names(ky_fan_k_norms) = K
#' Calculate Ky-Fan(k) norm
#'
#' @description This function takes in two covariance/correlation matrices, and calculates the Ky-Fan(k) norm of their differences for k=1,...,K
#'
#' @param cov_cor_X_1 p x p (p dimensions) covariance or correlation matrix for group 1
#' @param cov_cor_X_2 p x p  (p dimensions) covariance or correlation matrix for group 2
#' @param K Vector of integers, and these integers represent the Ky-Fan(k) norms that are included.
#'   E.g. K=c(1,5) means RACT is based on the Ky-Fan(1) and Ky-Fan(5) norm.
#' @return named vector of Ky-Fan(k) norms where names of each entry are values of k
calc_ky_fan_k<-function(cov_cor_X_1,cov_cor_X_2,K){
diff_mat = cov_cor_X_1-cov_cor_X_2
# Calculate top K singular values of difference matrix
top_K_singular_values = sort(RSpectra::svds(diff_mat,k=max(K),nu=0,nv=0)$d,decreasing=TRUE)
ky_fan_k_norms = cumsum(top_K_singular_values)[K]
names(ky_fan_k_norms) = K
return(ky_fan_k_norms)
}
#### Generate Simulated Data ####
generate_covariance_matrix<-function(cov_structure,snr,p,cov_rank,orig_cov_matrix=NULL){
# This function generates two matries based on one of the
# several covariance structures laid out in the paper
# INPUT
# cov_structure           - number related to which scenario we are using
# cov_rank                - rank of the low rank component
# snr                     - equivalent to tau^2 in Sigma=I+tau^2 UU^T
# p                       - dimension
# orig_cov_matrix         - only really used for scenario 5 where a change occurs
#                           in off diagonals and diagonals kept constant
# OUTPUT
# cov_matrix              - a covariance matrix
cov_matrix_1=matrix(data=0,nrow=p,ncol=p)
cov_matrix_2=matrix(data=0,nrow=p,ncol=p)
# Low Rank Component
if(cov_structure=='(LowRank)'){
b=matrix(rnorm(p*cov_rank),ncol=cov_rank)
cov_matrix_1=snr*(b%*%t(b))
b=matrix(rnorm(p*cov_rank),ncol=cov_rank)
cov_matrix_2=snr*(b%*%t(b))
}else if(cov_structure=='(LowRankBlockLarge)'){
block_size=round(p/2)
b=matrix(rnorm(block_size*cov_rank),ncol=cov_rank)
cov_matrix_1[1:block_size,1:block_size]=snr*(b%*%t(b))
b=matrix(rnorm((p-block_size)*cov_rank),ncol=cov_rank)
cov_matrix_1[(block_size+1):p,(block_size+1):p]=b%*%t(b)
b=matrix(rnorm(block_size*cov_rank),ncol=cov_rank)
cov_matrix_2[1:block_size,1:block_size]=snr*(b%*%t(b))
cov_matrix_2[(block_size+1):p,(block_size+1):p]=cov_matrix_1[(block_size+1):p,(block_size+1):p]
}else if(cov_structure=='(LowRankBlockSmall)'){
block_size=10
b=matrix(rnorm(block_size*cov_rank),ncol=cov_rank)
cov_matrix_1[1:block_size,1:block_size]=snr*(b%*%t(b))
b=matrix(rnorm((p-block_size)*cov_rank),ncol=cov_rank)
cov_matrix_1[(block_size+1):p,(block_size+1):p]=b%*%t(b)
b=matrix(rnorm(block_size*cov_rank),ncol=cov_rank)
cov_matrix_2[1:block_size,1:block_size]=snr*(b%*%t(b))
cov_matrix_2[(block_size+1):p,(block_size+1):p]=cov_matrix_1[(block_size+1):p,(block_size+1):p]
}else if(cov_structure=='(OffDiagonal)'){
block_size=round(p/2)
delete_block_size=ceiling(p/4-.00000001)
b=matrix(rnorm(block_size*cov_rank),ncol=cov_rank)
cov_matrix_1[1:block_size,1:block_size]=snr
cov_matrix_2=cov_matrix_1
cov_matrix_2[(delete_block_size+1):block_size,1:delete_block_size]=-1*snr
cov_matrix_2[1:delete_block_size,(delete_block_size+1):block_size]=-1*snr
diag(cov_matrix_1)=0
diag(cov_matrix_2)=0
}
# Add diagonals
cov_matrix_1=cov_matrix_1+diag(rep(1,p))
cov_matrix_2=cov_matrix_2+diag(rep(1,p))
return(list(cov_matrix_1,cov_matrix_2))
}
# For testing
cov_matrices = generate_covariance_matrix('(LowRank)',1,250,5)
length(cov_matrices)
n = 50
cov_matrices = generate_covariance_matrix('(LowRank)',1,250,5)
n = 50
cov_matrices = generate_covariance_matrix('(LowRank)',1,250,5)
X_1 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrix[[1]]))
X_2 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrix[[2]]))
n = 50
p = 250
cov_matrices = generate_covariance_matrix('(LowRank)',1,p,5)
X_1 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrix[[1]]))
X_2 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrix[[2]]))
n = 50
p = 250
cov_matrices = generate_covariance_matrix('(LowRank)',1,p,5)
X_1 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[1]]))
X_2 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[2]]))
image(Matrix(cov(t(X_1))))
library(Matrix)
image(Matrix(cov(t(X_1))))
image(Matrix(cov(t(X_1))),lwd=0)
image(Matrix(cov(t(X_2))),lwd=0)
n = 50
p = 250
cov_matrices = generate_covariance_matrix('(LowRank)',1,p,5)
X_1 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[1]]))
X_2 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[2]]))
K = NULL
cov=TRUE
# Calculate covariance/correlation matrices for each group
if(cov == TRUE){
cov_cor_X_1 = cov(t(X_1))
cov_cor_X_2 = cov(t(X_2))
}else if(cov == FALSE){
cov_cor_X_1 = cor(t(X_1))
cov_cor_X_2 = cor(t(X_2))
}else{
stop('cov must be set to TRUE/FALSE')
}
combined_X = cbind(X_1,X_2)
if(cov == TRUE){
cov_cor_combined_X = cov(t(combined_X))
}else if(cov == FALSE){
cov_cor_combined_X = cor(t(combined_X))
}else{
stop('cov must be set to TRUE/FALSE')
}
image(Matrix(cov_cor_combined_X))
image(Matrix(cov_cor_combined_X),lwd=0)
singular_values = svd(cov_cor_combined_X)$d
singular_values
# At most pooled correlation/covariance will have n (number of observations) non-zero singular values
singular_values = sort(RSpectra::svds(cov_cor_combined_X,k=min(nrow(combined_X,ncol(combined_X))),nu=0,nv=0)$d,decreasing=TRUE)
# At most pooled correlation/covariance will have n (number of observations) non-zero singular values
singular_values = sort(RSpectra::svds(cov_cor_combined_X,k=min(nrow(combined_X),ncol(combined_X)),nu=0,nv=0)$d,decreasing=TRUE)
singular_values
p
singular_values = svd(cov_cor_combined_X)$d
singular_values
K_pct=0.8
# Calculate sum of all singular values and determine where the cutoff should be
singular_value_cutoff = K_pct * sum(singular_values)
max_k = which(cumsum(combined_singular_values) >= singular_value_cutoff)[1]
max_k = which(cumsum(singular_values) >= singular_value_cutoff)[1]
singular_value_cutoff
max_k
max_K = which(cumsum(singular_values) >= singular_value_cutoff)[1]
K = seq(1,which(cumsum(singular_values) >= singular_value_cutoff)[1])
K
#'
#' @description This function takes in two covariance/correlation matrices, and calculates the Ky-Fan(k) norm of their differences for k=1,...,K
#'
#' @param X_1 p x n data matrix (p dimensions, n observations) for group 1
#' @param X_2 p x n data matrix (p dimensions, n observations) for group 2
#' @K_pct 0 < K_pct <= 1, where K_pct determines how large K should be so that sum of top K singular values of pooled covariance/correlation at least
#'   K_pct of the sum of all singular values. Default set at 0.8.
#' @param cov If cov=TRUE then K based off of pooled covariance, if cov=FALSE then based off of pooled correlation.
#'
#' @return vector of values c(1,...,K)
K_calculate<-function(X_1,X_2,K_pct = 0.8,cov = TRUE){
combined_X = cbind(X_1,X_2)
if(cov == TRUE){
cov_cor_combined_X = cov(t(combined_X))
}else if(cov == FALSE){
cov_cor_combined_X = cor(t(combined_X))
}else{
stop('cov must be set to TRUE/FALSE')
}
# At most pooled correlation/covariance will have n (number of observations) non-zero singular values, avoids situation where this
# function attempts to take a SVD of an extremely large matrix
singular_values = sort(RSpectra::svds(cov_cor_combined_X,
k=min(nrow(combined_X),ncol(combined_X)),nu=0,nv=0)$d,decreasing=TRUE)
# Calculate sum of all singular values and determine where the cutoff should be
singular_value_cutoff = K_pct * sum(singular_values)
K = seq(1,which(cumsum(singular_values) >= singular_value_cutoff)[1])
return(K)
}
n = 50
p = 250
cov_matrices = generate_covariance_matrix('(LowRank)',1,p,5)
X_1 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[1]]))
X_2 = x_matrix=t(MASS::mvrnorm(n=n,mu=rep(0,p),Sigm=cov_matrices[[2]]))
K = NULL
K_calculate(X_1,X_2,K_pct=0.5)
K_calculate(X_1,X_2,K_pct=0.8)
K_calculate(X_1,X_2)
K_calculate(X_1,X_2,K_pct=0.99)
document()
library(devtools)
document()
document()
rm(list = c("calc_ky_fan_k", "K_calculate"))
document()
document()
K = K_calculate(X_1,X_2, cov = cov)
K
devtools::install_github("daveveitch/RACT")
document()
library(devtools)
document()
cov_mat_1 = diag(p)
cov_mat_1[1:5,1:5]
cov_mat_2 = diag(p) + 0.5
cov_mat_2
cov_mat_2[1:5,1:5]
sqrt(cov_mat_1)
sqrt(cov_mat_2)
set.seed(1)
X_1 = matrix(rnorm(n*p),nrow=p,ncol=n)
A = matrix(rnorm(p*p),nrow=p,ncol=p)
X_2 = A%*%matrix(rnorm(n*p),nrow=p,ncol=n)
cov(t(X_1))
image(Matrix(cov(t(X_1)))
image(Matrix(cov(t(X_1))))
library(Matrix)
image(Matrix(cov(t(X_1))))
image(Matrix(cov(t(X_1))),lwd=0)
image(Matrix(cov(t(X_2))),lwd=0)
A_1 = rnorm(p)%*%rnorm(p)
A_1
A_1 = t(rnorm(p))%*%rnorm(p)
A_1
A_1 = matrix(rnorm(p),ncol=1)%*%rnorm(p)
A_1
a_1 = matrix(rnorm(p),ncol=1)
a_1%*%t(a_1)
image(Matrix(a_1%*%t(a_1)))
image(Matrix(a_1%*%t(a_1)),lwd=0)
set.seed(1)
a_1 = matrix(rnorm(p),ncol=1)
X_1 = a_1%*%t(a_1)%*%matrix(rnorm(n*p),nrow=p,ncol=n)
a_2 = matrix(rnorm(p),ncol=1)
X_2 = a_2%*%t(a_2)%*%matrix(rnorm(n*p),nrow=p,ncol=n)
image(Matrix(cov(t(X_2))),lwd=0)
image(Matrix(cov(t(X_1))),lwd=0)
X_1
dim(X_2)
dim(X_1)
document()
library(devtools)
document()
